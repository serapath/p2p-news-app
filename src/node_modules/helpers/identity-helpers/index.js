// This is currently commeneted due to version issues, will add back soon :)

// const b4a = require('b4a')
// const Autobase = require('autobase')
// const cc = require('compact-encoding')
// const IdentityKey = require('keet-identity-key')
// const process = require('bare-process')

// // the open and apply function copied from lejunes example (autobase-chat)

// function open(store) {
//   return store.get('identity-proofs')
// }

// async function apply(nodes, view, host) {
//   for (const { value } of nodes) {
//     if (value.addWriter) {
//       await host.addWriter(value.addWriter, { indexer: true })
//       continue
//     }
//     await view.append(value)
//   }
// }

// // show what's inside the autobase database
// async function show_autobase_view(autobase, label) {
//   console.log(label, '=== AUTOBASE VIEW ===')
  
//   try {
//     await autobase.update()
    
//     //if empty log empty
//     if (!autobase.view || autobase.view.length === 0) {
//       console.log(label, '(Empty)')
//       return
//     }
    
//     console.log(label, `${autobase.view.length} entries`)
    
//     // iterate over each autobase length to log the buffer by converting it to string
//     for (let i = 0; i < autobase.view.length; i++) {
//       try {
//         const buffer = await autobase.view.get(i)
//         console.log(label, `[${i}] ${b4a.toString(buffer)}`)
//       } catch (err) {
//         console.log(label, `[${i}] (Error: ${err.message})`)
//       }
//     }
    
//     console.log(label, 'Autobase:', b4a.toString(autobase.key, 'hex').substring(0, 16) + '...')
//     console.log(label, 'Local Key:', b4a.toString(autobase.local.key, 'hex').substring(0, 16) + '...')
    
//     // log how many writer (who can append to our autobase are)
//     if (autobase.writers && Array.isArray(autobase.writers)) {
//       console.log(label, `${autobase.writers.length} writers`)
//     }
    
//     console.log(label, '========================')
//   } catch (err) {
//     console.error(label, 'Error displaying autobase:', err.message)
//   }
// }

// // I have having problems with json so though just put all info as strings with : separation
// async function store_device_info(autobase, info) {
//   const entry = [
//     'DEVICE_INFO',
//     info.device_public_key,
//     info.identity_public_key || '',
//     info.device_name,
//     info.device_type,
//     info.paired_with || '',
//     info.identity_mnemonic || '', // Store identity mnemonic for main devices
//     Date.now().toString()
//   ].join(':')
  
//   await autobase.append(entry)
//   await autobase.update()
// }

// // to get all the device from autobase
// async function get_stored_devices(autobase) {
//   await autobase.update()
//   await new Promise(resolve => setTimeout(resolve, 500)) // giving it time to sync 
  
//   const devices = []
//   const identity_proofs = []
  
//   if (!autobase.view || autobase.view.length === 0) {
//     return { devices, identity_proofs }
//   }
  
//   for (let i = 0; i < autobase.view.length; i++) {
//     try {
//       const entry = await autobase.view.get(i)
//       if (!entry) continue
      
//       const entry_str = b4a.toString(entry)

//       // obviously were only storing the device/identity proof info, but can in future store other stuff so better to check
//       if (entry_str.startsWith('DEVICE_INFO:')) {
//         const parts = entry_str.split(':')
//         if (parts.length >= 7) { // Updated to handle identity_mnemonic
//           devices.push({
//             device_public_key: parts[1],
//             identity_public_key: parts[2] || null,
//             device_name: parts[3],
//             device_type: parts[4],
//             paired_with: parts[5] || null,
//             identity_mnemonic: parts[6] || null, // Store identity mnemonic
//             timestamp: parseInt(parts[7]) || 0
//           })
//         }

//       } else if (entry_str.startsWith('IDENTITY_PROOF:')) {
//         const parts = entry_str.split(':')
//         if (parts.length >= 4) {
//           identity_proofs.push({
//             auxiliary_public_key: parts[1],
//             proof_data: parts[2],
//             identity_public_key: parts[3],
//             main_device_name: parts[4] || 'unknown',
//             auxiliary_device_name: parts[5] || 'unknown'
//           })
//         }
//       }
//     } catch (err) {
//       // Skip broken entries
//     }
//   }
  
//   return { devices, identity_proofs }
// }

// // get existing identity or create a new one
// async function get_or_create_identity_key(autobase, device_name, label) {
//   const { devices } = await get_stored_devices(autobase)
  
//   // look for main device with saved identity
//   const main_device = devices.find(d => d.device_type === 'main' && d.identity_mnemonic)
  
//   if (main_device && main_device.identity_mnemonic) {
//     console.log(label, 'Reusing existing identity key')
//     try {
//       const identity = await IdentityKey.from({ mnemonic: main_device.identity_mnemonic })
//       return { 
//         identity, 
//         mnemonic: main_device.identity_mnemonic,
//         identity_public_key: identity.identityPublicKey,
//         is_new: false
//       }
//     } catch (err) {
//       console.error(label, 'Failed to load existing identity, creating new one:', err.message)
//     }
//   }
  
//   // create brand new identity
//   console.log(label, 'Creating new identity key')
//   const mnemonic = IdentityKey.generateMnemonic()
//   const identity = await IdentityKey.from({ mnemonic })
  
//   return { 
//     identity, 
//     mnemonic,
//     identity_public_key: identity.identityPublicKey,
//     is_new: true
//   }
// }

// // Check if a device belongs to our network (meaning its our device)
// async function belongs_to_my_network(peer_device_key, my_device_key, autobase, label) {
//   try {
//     const { devices, identity_proofs } = await get_stored_devices(autobase)
    
//     // Check if peer is in our device list
//     const peer_device = devices.find(d => d.device_public_key === peer_device_key)
//     if (peer_device) {
//       console.log(label, `${peer_device.device_name} is in my network`)
//       return true
//     }
    
//     // Check if we share the same identity
//     const my_proof = identity_proofs.find(p => p.auxiliary_public_key === my_device_key)
//     const peer_proof = identity_proofs.find(p => p.auxiliary_public_key === peer_device_key)
    
//     if (my_proof && peer_proof && my_proof.identity_public_key === peer_proof.identity_public_key) {
//       console.log(label, 'Cross-device verification: We share the same identity')
//       return true
//     }
    
//     return false
//   } catch (err) {
//     console.error(label, 'Error checking identity:', err.message)
//     return false
//   }
// }

// // Figure out if this device should be main or auxiliary
// async function determine_device_role(my_public_key, autobase) {
//   const { devices } = await get_stored_devices(autobase)
  
//   const my_device = devices.find(d => d.device_public_key === my_public_key.toString('hex'))

//   if (my_device) {
//     return { role: my_device.device_type, is_known: true, all_devices: devices }
//   }
  
//   const main_devices = devices.filter(d => d.device_type === 'main')
//   if (main_devices.length === 0) {
//     return { role: 'main', is_known: false, all_devices: devices }
//   } else {
//     return { role: 'auxiliary', is_known: false, all_devices: devices }
//   }
// }

// // create proof that devices belong to same identity
// async function create_identity_proof(main_keypair, aux_keypair, autobase, device_name, label) {
//   try {
//     // Get or create persistent identity key
//     const identity_data = await get_or_create_identity_key(autobase, device_name, label)
//     const { identity, mnemonic, identity_public_key } = identity_data
    
//     // Create proof for auxiliary device
//     const proof = await identity.bootstrap(aux_keypair.publicKey)
    
//     return {
//       proof,
//       identity_public_key,
//       mnemonic,
//       is_new_identity: identity_data.is_new
//     }
//   } catch (err) {
//     console.error('Failed to create identity proof:', err)
//     return null
//   }
// }

// // check if an identity proof is valid
// async function verify_identity_proof(proof, expected_key) {
//   try {
//     const info = IdentityKey.verify(proof, null, { expectedDevice: expected_key })
//     return info !== null && b4a.equals(info.devicePublicKey, expected_key)
//   } catch (err) {
//     return false
//   }
// }

// // sometime it checks and fails because of slow sync, so now ten tries
// async function start_verification_monitor(autobase, my_device_key, label) {
//   let verification_found = false
//   let check_count = 0
//   const max_checks = 60
  
//   const monitor_interval = setInterval(async () => {
//     check_count++
    
//     if (verification_found || check_count > max_checks) {
//       clearInterval(monitor_interval)
//       if (check_count > max_checks) {
//         console.log(label, 'Verification timeout')
//       }
//       return
//     }
    
//     try {
//       await autobase.update()
//       const { identity_proofs, devices } = await get_stored_devices(autobase)
      
//       const my_proof = identity_proofs.find(p => p.auxiliary_public_key === my_device_key.toString('hex'))
      
//       if (my_proof) {
//         const proof = Buffer.from(my_proof.proof_data, 'hex')
//         const is_valid = await verify_identity_proof(proof, my_device_key)
        
//         if (is_valid) {
//           verification_found = true
//           console.log(label, 'VERIFICATION SUCCESS!')
//           console.log(label, `Main: ${my_proof.main_device_name} | Aux: ${my_proof.auxiliary_device_name}`)
//           console.log(label, `Identity: ${my_proof.identity_public_key.substring(0, 16)}...`)
//           console.log(label, `Network has ${devices.length} devices`)
          
//           setTimeout(() => show_autobase_view(autobase, label), 1000)
//           clearInterval(monitor_interval)
//         }
//       }
//     } catch (err) {
//       // Keep trying
//     }
//   }, 5000)
// }

// // Wait for user to type something
// function wait_for_user_input(prompt_message) {
//   return new Promise((resolve) => {
//     console.log(prompt_message)
    
//     if (process.stdin.setRawMode) process.stdin.setRawMode(false)
//     process.stdin.resume()
//     process.stdin.setEncoding('utf8')
    
//     let input = ''
    
//     const on_data = (chunk) => {
//       if (chunk === '\n' || chunk === '\r' || chunk === '\r\n') {
//         process.stdin.removeListener('data', on_data)
//         process.stdin.pause()
//         resolve(input.trim())
//       } else {
//         input += chunk
//       }
//     }
    
//     process.stdin.on('data', on_data)
//   })
// }

// // Set up the autobase system depending upon options 
// async function initialize_autobase(store, options = {}) {
//   const { invite_key, forced_mode, name, mnemonic_data, label } = options
  
//   let autobase
//   let device_role_info
//   let actual_mode
//   let manually_added_writers = new Set()
  
//   if (forced_mode) {
//     actual_mode = forced_mode
//     if (forced_mode === 'invite') {
//       // Main device mode - create new autobase
//       autobase = new Autobase(store, null, { apply, open, valueEncoding: cc.any })
//       await autobase.ready()
//       console.log(label, 'Invite key:', b4a.toString(autobase.key, 'hex'))
      
//       const aux_local_key = await wait_for_user_input(label + ' Paste auxiliary device key:')
      
//       if (aux_local_key && aux_local_key.length === 64) {
//         await autobase.append({ addWriter: Buffer.from(aux_local_key, 'hex') })
//         await autobase.update()
//         manually_added_writers.add(aux_local_key)
//         console.log(label, 'Added auxiliary device as writer')
        
//         setTimeout(() => show_autobase_view(autobase, label), 5000)
//       } else {
//         console.error(label, 'Invalid key format')
//       }
      
//     } else if (forced_mode === 'pair' && invite_key) {
//       // Auxiliary device mode - connect to existing autobase
//       autobase = new Autobase(store, Buffer.from(invite_key, 'hex'), { apply, open, valueEncoding: cc.any })
//       await autobase.ready()
//       console.log(label, 'Connected to autobase')
//       console.log(label, 'our key:', b4a.toString(autobase.local.key, 'hex'))
      
//       setTimeout(() => start_verification_monitor(autobase, mnemonic_data.keypair.publicKey, label), 3000)
//     }
//   } else {
//     // Auto-determine what kind of device this is
//     try {
//       const temp_autobase = new Autobase(store, null, { apply, open, valueEncoding: cc.any })
//       await temp_autobase.ready()
      
//       device_role_info = await determine_device_role(mnemonic_data.keypair.publicKey, temp_autobase)
      
//       if (device_role_info.role === 'main') {
//         actual_mode = 'invite'
//         autobase = temp_autobase
//         console.log(label, 'Main device mode')
//       } else {
//         actual_mode = 'pair'
//         autobase = temp_autobase
//         console.log(label, 'Auxiliary device mode')
        
//         if (!device_role_info.is_known) {
//           setTimeout(() => start_verification_monitor(autobase, mnemonic_data.keypair.publicKey, label), 3000)
//         }
//       }
      
//       setTimeout(() => show_autobase_view(autobase, label), 5000)
      
//     } catch (err) {
//       actual_mode = 'invite'
//       autobase = new Autobase(store, null, { apply, open, valueEncoding: cc.any })
//       await autobase.ready()
//       console.log(label, 'New main device')
      
//       setTimeout(() => show_autobase_view(autobase, label), 5000)
//     }
//   }
  
//   const is_main_device = actual_mode === 'invite'

//   // Save this device info if its new main device
//   if (is_main_device && (!device_role_info || !device_role_info.is_known)) {
//     // Get or create identity for main device
//     const identity_data = await get_or_create_identity_key(autobase, name, label)
    
//     await store_device_info(autobase, {
//       device_public_key: mnemonic_data.keypair.publicKey.toString('hex'),
//       device_name: name,
//       device_type: 'main',
//       identity_mnemonic: identity_data.mnemonic, // Store for persistence
//       identity_public_key: identity_data.identity_public_key.toString('hex')
//     })
    
//     if (identity_data.is_new) {
//       console.log(label, 'Created new identity for main device')
//     } else {
//       console.log(label, 'Loaded existing identity for main device')
//     }
//   }

//   return {
//     autobase,
//     actual_mode,
//     is_main_device,
//     manually_added_writers,
//     device_role_info
//   }
// }

// // Handle messages between devices for identity verification
// async function handle_identity_protocol(message, autobase, is_main_device, manually_added_writers, mnemonic_data, name, label) {
//   const peer_device_key = Buffer.from(message.data.device_public_key, 'hex')
//   const peer_device_key_hex = peer_device_key.toString('hex')
  
//   const { devices } = await get_stored_devices(autobase)
//   const known_peer = devices.find(d => d.device_public_key === peer_device_key_hex)
  
//   if (known_peer) {
//     console.log(label, `Our other device ${known_peer.device_name} reconnected`)
//     return
//   }
  
//   if (is_main_device && message.data.mode === 'pair') {
//     // Check if this device belongs to our network
//     const belongs_to_network = await belongs_to_my_network(
//       peer_device_key_hex, 
//       mnemonic_data.keypair.publicKey.toString('hex'), 
//       autobase, 
//       label
//     )
    
//     // if not, its another peer.
//     if (!belongs_to_network && manually_added_writers.size === 0) {
//       console.log(label, `Observing ${message.data.name} from different network`)
//       return
//     }
    
//     const { identity_proofs } = await get_stored_devices(autobase)
//     const proof_exists = identity_proofs.some(p => p.auxiliary_public_key === peer_device_key_hex)
    
//     if (proof_exists) return
    
//     console.log(label, 'Creating identity proof with persistent identity...')
    
//     const identity_proof = await create_identity_proof(
//       mnemonic_data.keypair,
//       { publicKey: peer_device_key },
//       autobase,
//       name,
//       label
//     )
    
//     if (identity_proof) {
//       const proof_string = [
//         'IDENTITY_PROOF',
//         peer_device_key_hex,
//         identity_proof.proof.toString('hex'),
//         identity_proof.identity_public_key.toString('hex'),
//         name,
//         message.data.name
//       ].join(':')
      
//       await autobase.append(proof_string)
//       await autobase.update()
      
//       await store_device_info(autobase, {
//         device_public_key: peer_device_key_hex,
//         device_name: message.data.name,
//         device_type: 'auxiliary',
//         paired_with: mnemonic_data.keypair.publicKey.toString('hex'),
//         identity_public_key: identity_proof.identity_public_key.toString('hex')
//       })
      
//       console.log(label, `Added ${message.data.name} to network`)
//       console.log(label, `Identity: ${identity_proof.identity_public_key.toString('hex').substring(0, 16)}...`)
//       setTimeout(() => show_autobase_view(autobase, label), 2000)
//     }
//   } else if (is_main_device) {
//     console.log(label, `Connecter to different peer named ${message.data.name}`)
//   }
// }

// module.exports = {
//   initialize_autobase,
//   handle_identity_protocol
// }
