// P2P blog helper 
const b4a = require('b4a')
const Hyperdrive = require('hyperdrive')
const event_emitter = require('events')

let store, blog_core, drive, emitter, connected_peers = new Map()
let subscription_store = null;
function set_subscription_store(store) { subscription_store = store; }

// local storage for keeping track of subscribed peers
function get_local_subscribed_peers() {
  if (subscription_store) return subscription_store.get();
  try { return JSON.parse(localStorage.getItem('subscribed_peers') || '[]') } catch { return [] }
}
function add_local_subscribed_peer(key) {
  if (subscription_store) return subscription_store.add(key);
  const arr = get_local_subscribed_peers()
  if (!arr.includes(key)) {
    arr.push(key)
    localStorage.setItem('subscribed_peers', JSON.stringify(arr))
  }
}
function remove_local_subscribed_peer(key) {
  if (subscription_store) return subscription_store.remove(key);
  localStorage.setItem('subscribed_peers', JSON.stringify(get_local_subscribed_peers().filter(k => k !== key)))
}

// main blog initialization (the init blog so peers can discover it)
async function init_blog(store_instance, username) {
  store = store_instance
  blog_core = store.get({ name: 'blog-feed' })
  await blog_core.ready()
  drive = new Hyperdrive(store)
  await drive.ready()
  emitter = new event_emitter()
 // if blog core is empty, append the blog init
  if (blog_core.length === 0) {
    await blog_core.append(JSON.stringify({
      type: 'blog-init',
      drive_key: b4a.toString(drive.key, 'hex'),
      title: `${username}'s Blog`,
      username,
      created: Date.now()
    }))
  }
  store.on('core', handle_new_core)
  blog_core.on('append', () => emitter.emit('update'))
  return { get_my_posts, get_peer_blogs, get_discovered_blogs }
}

// peer discovery and auto re-listen logic
async function handle_new_core(core) {
  const key = b4a.toString(core.key, 'hex')
  if (key === b4a.toString(blog_core.key, 'hex')) return
  await core.ready()
  let attempts = 0
  while (core.length === 0 && attempts++ < 20) await new Promise(r => setTimeout(r, 100))
  if (core.length === 0) return
  try {
    const data = JSON.parse(b4a.toString(await core.get(0)))
    if (data.type === 'blog-init') {
      console.log(`Peer discovered: ${data.username} - ${data.title}`)
      const peer_data = { username: data.username, title: data.title, drive_key: data.drive_key }
      connected_peers.set(key, peer_data)
      if (get_local_subscribed_peers().includes(key)) {
        console.log(`Peer ${data.username} is back online (previously subscribed)`)
        await reestablish_listeners(key, peer_data)
      }
      emitter.emit('update')
    }
  } catch (err) { console.log(`Error processing core: ${err.message}`) }
}

// re-listen and sync for previously subscribed peers
async function reestablish_listeners(key, peer_data) {
  try {
    console.log(`Reconnecting to previously subscribed peer: ${peer_data.username}`)
    const peer_core = store.get(b4a.from(key, 'hex'))
    await peer_core.ready()
    peer_core.download({ start: 0, end: -1 })
    const peer_drive = new Hyperdrive(store, b4a.from(peer_data.drive_key, 'hex'))
    await peer_drive.ready(); peer_drive.download('/')
    await new Promise(resolve => {
      const check = () => (peer_core.downloaded || peer_core.length > 0) ? setTimeout(resolve, 1000) : setTimeout(check, 100)
      check()
    })
    let new_posts = 0
    for (let i = 1; i < peer_core.length; i++) {
      try {
        const post = JSON.parse(b4a.toString(await peer_core.get(i)))
        if (post.type === 'blog-post') {
          const post_id = `${key}:${post.title}:${post.created}`
          if (!(await has_peer_post(post_id))) {
            const content = await peer_drive.get(post.filepath)
            if (content) {
              const our_path = `/peer_posts/${key}/${post.filepath.split('/').pop()}`
              await drive.put(our_path, content)
              await blog_core.append(JSON.stringify({
                type: 'peer-blog-post', peer_key: key, title: post.title, filepath: our_path, created: post.created, post_id
              }))
              console.log(`Reconnected: Downloaded "${post.title}" from ${peer_data.username}`)
              new_posts++
            }
          }
        }
      } catch {}
    }
    if (new_posts > 0) console.log(`Reconnected: ${new_posts} new posts from ${peer_data.username}`)
    else console.log(`Reconnected: No new posts from ${peer_data.username}`)
    peer_core.on('append', async () => {
      try {
        const latest_post = JSON.parse(b4a.toString(await peer_core.get(peer_core.length - 1)))
        if (latest_post.type === 'blog-post') {
          const post_id = `${key}:${latest_post.title}:${latest_post.created}`
          if (!(await has_peer_post(post_id))) {
            const content = await peer_drive.get(latest_post.filepath)
            if (content) {
              const our_path = `/peer_posts/${key}/${latest_post.filepath.split('/').pop()}`
              await drive.put(our_path, content)
              await blog_core.append(JSON.stringify({
                type: 'peer-blog-post', peer_key: key, title: latest_post.title, filepath: our_path, created: latest_post.created, post_id
              }))
              console.log(`New post from ${peer_data.username}: "${latest_post.title}"`)
              emitter.emit('update')
            }
          }
        }
      } catch {}
    })
    emitter.emit('update')
    return true
  } catch (err) { console.log('Reconnection error:', err); return false }
}

// create a new post in your own blog
async function create_post(title, content) {
  try {
    const path = `/posts/${Date.now()}.md`
    await drive.put(path, b4a.from(content))
    await blog_core.append(JSON.stringify({
      type: 'blog-post', title, filepath: path, created: Date.now()
    }))
    emitter.emit('update')
    return true
  } catch { return false }
}

// subscribe to a peer's blog
async function subscribe(key) {
  try {
    const peer_core = store.get(b4a.from(key, 'hex'))
    await peer_core.ready()
    if (peer_core.length === 0) return false
    const data = JSON.parse(b4a.toString(await peer_core.get(0)))
    if (!data.drive_key || data.type !== 'blog-init') return false
    console.log(`Subscribing to ${data.username}...`)
    peer_core.download({ start: 0, end: -1 })
    const peer_drive = new Hyperdrive(store, b4a.from(data.drive_key, 'hex'))
    await peer_drive.ready(); peer_drive.download('/')
    await new Promise(resolve => {
      const check = () => (peer_core.downloaded || peer_core.length > 0) ? setTimeout(resolve, 1000) : setTimeout(check, 100)
      check()
    })
    let posts_found = 0, posts_downloaded = 0
    for (let i = 1; i < peer_core.length; i++) {
      try {
        const post = JSON.parse(b4a.toString(await peer_core.get(i)))
        if (post.type === 'blog-post') {
          posts_found++
          const post_id = `${key}:${post.title}:${post.created}`
          if (!(await has_peer_post(post_id))) {
            const content = await peer_drive.get(post.filepath)
            if (content) {
              const our_path = `/peer_posts/${key}/${post.filepath.split('/').pop()}`
              await drive.put(our_path, content)
              await blog_core.append(JSON.stringify({
                type: 'peer-blog-post', peer_key: key, title: post.title, filepath: our_path, created: post.created, post_id
              }))
              console.log(`Downloaded: "${post.title}" from ${data.username}`)
              posts_downloaded++
            }
          }
        }
      } catch {}
    }
    console.log(`Summary: ${posts_found} posts found, ${posts_downloaded} downloaded from ${data.username}`)
    await blog_core.append(JSON.stringify({
      type: 'peer-blog-init', peer_key: key, username: data.username, title: data.title, drive_key: data.drive_key, subscribed_at: Date.now()
    }))
    peer_core.on('append', async () => {
      try {
        const latest_post = JSON.parse(b4a.toString(await peer_core.get(peer_core.length - 1)))
        if (latest_post.type === 'blog-post') {
          const post_id = `${key}:${latest_post.title}:${latest_post.created}`
          if (!(await has_peer_post(post_id))) {
            const content = await peer_drive.get(latest_post.filepath)
            if (content) {
              const our_path = `/peer_posts/${key}/${latest_post.filepath.split('/').pop()}`
              await drive.put(our_path, content)
              await blog_core.append(JSON.stringify({
                type: 'peer-blog-post', peer_key: key, title: latest_post.title, filepath: our_path, created: latest_post.created, post_id
              }))
              console.log(`New post from ${data.username}: "${latest_post.title}"`)
              emitter.emit('update')
            }
          }
        }
      } catch {}
    })
    add_local_subscribed_peer(key)
    emitter.emit('update')
    return true
  } catch (err) { console.log('Subscribe error:', err); return false }
}

// unsubscribe from a peer's blog
async function unsubscribe(key) {
  try {
    await blog_core.append(JSON.stringify({
      type: 'peer-blog-unsubscribe', peer_key: key, unsubscribed_at: Date.now()
    }))
    remove_local_subscribed_peer(key)
    emitter.emit('update')
    return true
  } catch { return false }
}

// get your own posts
async function get_my_posts() {
  const posts = []
  for (let i = 1; i < blog_core.length; i++) {
    try {
      const entry = JSON.parse(b4a.toString(await blog_core.get(i)))
      if (entry.type === 'blog-post') {
        const content = await drive.get(entry.filepath)
        if (content) posts.push({ ...entry, content: b4a.toString(content) })
      }
    } catch {}
  }
  return posts
}

// check if we already have a peer's post
async function has_peer_post(post_id) {
  for (let i = 1; i < blog_core.length; i++) {
    try {
      const entry = JSON.parse(b4a.toString(await blog_core.get(i)))
      if (entry.type === 'peer-blog-post' && entry.post_id === post_id) return true
    } catch {}
  }
  return false
}

// get all blogs you are subscribed to, with metadata and posts
async function get_peer_blogs() {
  const blogs = new Map(), subscribed_keys = [], peer_metadata = new Map()
  for (let i = 1; i < blog_core.length; i++) {
    try {
      const entry = JSON.parse(b4a.toString(await blog_core.get(i)))
      if (entry.type === 'peer-blog-init') {
        subscribed_keys.push(entry.peer_key)
        peer_metadata.set(entry.peer_key, {
          username: entry.username, title: entry.title, drive_key: entry.drive_key, subscribed_at: entry.subscribed_at
        })
      }
      if (entry.type === 'peer-blog-unsubscribe') {
        const idx = subscribed_keys.indexOf(entry.peer_key)
        if (idx > -1) subscribed_keys.splice(idx, 1)
        peer_metadata.delete(entry.peer_key)
      }
    } catch {}
  }
  for (const key of subscribed_keys) {
    const posts = []
    for (let i = 1; i < blog_core.length; i++) {
      try {
        const entry = JSON.parse(b4a.toString(await blog_core.get(i)))
        if (entry.type === 'peer-blog-post' && entry.peer_key === key) {
          const content = await drive.get(entry.filepath)
          if (content) posts.push({ title: entry.title, content: b4a.toString(content), created: entry.created })
        }
      } catch {}
    }
    const metadata = peer_metadata.get(key) || {}
    blogs.set(key, { key, posts, username: metadata.username, title: metadata.title, drive_key: metadata.drive_key, subscribed_at: metadata.subscribed_at })
  }
  return blogs
}

// get all discovered blogs (peers)
async function get_discovered_blogs() { return connected_peers }

const on_update = cb => emitter.on('update', cb)
const get_my_core_key = () => blog_core?.key

module.exports = {
  init_blog,
  handle_new_core,
  create_post,
  subscribe,
  unsubscribe,
  get_my_posts,
  get_peer_blogs,
  get_discovered_blogs,
  get_my_core_key,
  on_update,
  set_subscription_store
}