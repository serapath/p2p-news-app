const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const crypto = require('hypercore-crypto')
const process = require('bare-process')
const protomux = require('protomux')
const c = require('compact-encoding')
const { create_noise_keypair } = require('../helpers/crypto-helpers/index.js')
const { parseFeedKey } = require('../helpers/parsing-helpers/index.js')
const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

/******************************************************************************
  START
******************************************************************************/
async function startNativePeer (cliArgs) {
  const parsed_args = parse(cliArgs)
  const validated_args = validate(parsed_args)
  const name = validated_args['--name'] || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  const opts = {
    namespace: 'noisekeys',
    seed: crypto.randomBytes(32),
    name: 'noise'
  }
  const { publicKey, secretKey } = create_noise_keypair(opts)
  console.log(label, { peerkey: publicKey.toString('hex') })
  const key_pair = { publicKey, secretKey }
  const store = new Corestore(`./storage-${name}`)
  const core = store.get({ name: 'test-core' })
  await core.ready()
  console.log(label, 'âœ… Successfully created a new core with the key')
  console.log(label, { corekey: core.key.toString('hex') })
  await core.append('Hello, peer!')
  const swarm = new Hyperswarm({ key_pair })
  swarm.on('connection', onconnection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  async function onconnection (socket, info) {
    console.log(label, 'New Peer Joined, Their Public Key is: ', info.publicKey.toString('hex'))
    socket.on('error', onerror)

    const mux = new protomux(socket)
    let hasReceivedFeedkey = false

    const identity_channel = mux.createChannel({
      protocol: 'identity-exchange',
      onopen: () => {
        console.log(label, 'Identity channel opened')

        const protocol_msg = identity_channel.addMessage({
          encoding: c.json,
          onmessage: async (message) => {
            try {
              // Handle identity message
              if (message.type === 'protocol') {
                console.log(label, `Peer ${message.name} is ${message.data}`)
              }

              // Handle feedkey message (for both native and browser peers)
              if (message.type === 'feedkey' && !hasReceivedFeedkey) {
                hasReceivedFeedkey = true
                const keyBuffer = parseFeedKey(message.feedkey)

                if (!keyBuffer) return

                const hexKey = keyBuffer.toString('hex')
                console.log(label, 'Received peer key:', hexKey.substring(0, 16) + '...')

                const cloned_core = store.get(keyBuffer)
                cloned_core.on('append', async () => {
                  console.log(label, 'New data appended to cloned core')
                  const latest = await cloned_core.get(cloned_core.length - 1)
                  console.log(label, 'Received:', latest.toString('utf-8'))
                })
                await cloned_core.ready()
                console.log(label, 'Cloned core ready:', cloned_core.key.toString('hex'))
    }

              if (message.type === 'protocol' || message.type === 'feedkey') {
                store.replicate(socket)
              }
            } catch (err) {
              console.error(label, 'Error handling message:', err)
            }
          }
        })

        console.log(label, 'Sending our identity and core key')
        protocol_msg.send({
          type: 'protocol',
          name: name,
          data: 'native'
        })
        protocol_msg.send({
          type: 'feedkey',
          feedkey: core.key.toString('hex')
        })
      }
    })

    identity_channel.open()
  }

  function onerror (err) {
    console.log(label, 'socket error', err)
  }



}

/******************************************************************************
  HELPER (CLI ARGUMENTS)
******************************************************************************/

function parse (L) {
  const arr = []
  for (let i = 0; i < L.length; i += 2) arr.push([L[i], L[i + 1]])
  return Object.fromEntries(arr)
}

function validate (opts) {
  if (!opts['--name']) console.warn('Warning: --name not provided. Using default name.')
  return opts // We allow missing name now, will use default
}

module.exports = {
  start: startNativePeer
}
