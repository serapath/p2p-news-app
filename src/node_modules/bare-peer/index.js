const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const process = require('bare-process')
const protomux = require('protomux')
const { create_mnemonic_keypair, save, load } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')
const blog_helper = require('../helpers/blog-helpers/index.js')
const Hyperdrive = require('hyperdrive')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

async function start_native_peer(options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  let seedphrase = await load(name)
  let mnemonic_data
  
  if (seedphrase) {
    console.log(label, 'Loaded existing seedphrase')
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise',
      mnemonic: seedphrase
    })
  } else {
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise'
    })
    await save(mnemonic_data.mnemonic, name)
    console.log(label, 'Generated and saved new mnemonic')
  }
  
  console.log(label, 'Generated mnemonic:', mnemonic_data.mnemonic)
  console.log(label, 'Peer key:', mnemonic_data.keypair.publicKey.toString('hex'))

  const store = new Corestore(`./storage-${name}`)
  await blog_helper.init_blog(store, name)
  const blog_core = store.get({ name: 'blog-feed' })
  await blog_core.ready()
  console.log(label, 'âœ… Blog system ready')

  const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })
  const discovered_peers = new Map()
  const active_connections = new Map()
  const peer_cores = new Map()

  swarm.on('connection', on_connection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  async function on_connection(socket, info) {
    const peer_id = info.publicKey.toString('hex')

    if (active_connections.has(peer_id)) {
      console.log(label, `Duplicate connection ignored [${peer_id.slice(0, 8)}]`)
      return
    }

    console.log(label, `Connected to peer [${peer_id.slice(0, 8)}]`)
    active_connections.set(peer_id, socket)

    socket.on('close', () => {
      console.log(label, `Peer disconected [${peer_id.slice(0, 8)}]`)
      active_connections.delete(peer_id)
      peer_cores.delete(peer_id)
    })

    socket.on('error', err => {
      if (!err.message?.includes('Duplicate connection')) {
        console.log(label, `connection error [${peer_id.slice(0, 8)}]:`, err.message)
      }
    })

    const mux = new protomux(socket)

    const handlers = {
      on_protocol: async (message, send) => {
        if (message.data && message.data.name) {
          const peer_info = {
            name: message.data.name,
            username: message.data.name,
            mode: message.data.mode || 'unknown',
            last_seen: Date.now(),
            peer_id: message.data.device_public_key
          }
          discovered_peers.set(peer_id, peer_info)
          console.log(label, `Discovered peer: ${message.data.name} (${message.data.mode})`)
        }
      },
      
      on_feedkey: async ({ key_buffer }, send) => {
        try {
          const hex_key = b4a.toString(key_buffer, 'hex')
          
          console.log(label, `Received feed key from [${peer_id.slice(0, 8)}]: ${hex_key.slice(0, 8)}`)
          
          const peer_core = store.get(key_buffer)
          await peer_core.ready()
          peer_cores.set(peer_id, { core: peer_core, hex_key })
          
          if (peer_core.length > 0) {
            try {
              const init_data = JSON.parse(b4a.toString(await peer_core.get(0)))
              if (init_data.type === 'blog-init' && init_data.username) {
                console.log(label, `Found blog: "${init_data.title}" by ${init_data.username} [${hex_key.slice(0, 8)}]`)
                const peer_info = discovered_peers.get(peer_id) || {}
                peer_info.blog_title = init_data.title
                peer_info.drive_key = init_data.drive_key || init_data.driveKey
                peer_info.initialized = true
                discovered_peers.set(peer_id, peer_info)
                console.log(label, `Blog ready for subscription: ${init_data.username} [${hex_key.slice(0, 8)}]`)
              }
            } catch (err) {
              console.log(label, `Could not parse blog init for [${hex_key.slice(0, 8)}]`)
            }
          } else {
            console.log(label, `Empty blog core from [${hex_key.slice(0, 8)}] - waiting for data`)
            const onFirstAppend = async () => {
              try {
                const init_data = JSON.parse(b4a.toString(await peer_core.get(0)))
                if (init_data.type === 'blog-init' && init_data.username) {
                  console.log(label, `Blog initialized: "${init_data.title}" by ${init_data.username} [${hex_key.slice(0, 8)}]`)
                  const peer_info = discovered_peers.get(peer_id) || {}
                  peer_info.blog_title = init_data.title
                  peer_info.drive_key = init_data.drive_key || init_data.driveKey
                  peer_info.initialized = true
                  discovered_peers.set(peer_id, peer_info)
                }
              } catch (err) {
                console.log(label, `Error processing blog init [${hex_key.slice(0, 8)}]:`, err.message)
              }
              peer_core.removeListener('append', onFirstAppend)
            }
            peer_core.once('append', onFirstAppend)
          }
          
        } catch (err) {
          console.error(label, `Error handling peer core [${peer_id.slice(0, 8)}]:`, err)
        }
      }
    }

    const init_fn = (send) => {
      try {
        console.log(label, `Sending identity to [${peer_id.slice(0, 8)}]`)
        send({
          type: 'protocol',
          data: {
            name: name,
            mode: 'native',
            device_public_key: mnemonic_data.keypair.publicKey.toString('hex')
          }
        })
        send({
          type: 'feedkey',
          data: blog_core.key.toString('hex')
        })
        console.log(label, `Identity exchanged with [${peer_id.slice(0, 8)}]`)
      } catch (err) {
        console.error(label, `Error in identity exchange [${peer_id.slice(0, 8)}]:`, err)
      }
    }

    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: 'native',
      label
    })
    
    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    store.replicate(socket)
  }

  return {
    blog_helper,
    store,
    swarm,
    blog_core,
    discovered_peers,
    subscribe_to_peer: async function (peer_id) {
      console.log(label, `Loading entries for peer [${peer_id.slice(0, 8)}]`)
    const peer_info = discovered_peers.get(peer_id)
    const peer_core_info = peer_cores.get(peer_id)
      if (!peer_info || !peer_core_info || !peer_info.drive_key) {
        console.log(label, `Subscription failed, missing peer data for [${peer_id.slice(0, 8)}]`)
      return false
    }
    try {
      const { core: peer_core, hex_key, short_key } = peer_core_info
        const peer_drive = new Hyperdrive(store, b4a.from(peer_info.drive_key, 'hex'))
        await peer_drive.ready()
      
      console.log(label, `starting data check for ${peer_info.username} [${short_key}]`)
      console.log(label, `Peer core length: ${peer_core.length} entries`)
      
      if (peer_core.length > 0) {
        console.log(label, `Downloading ${peer_core.length} entries from ${peer_info.username}`)
        peer_core.download({ start: 0, end: -1 })
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
      
      let processed_posts = 0
      let blog_posts = 0
        
        // Track what we've already appended to avoid duplicates
        const processed_entries = new Set()
      
      console.log(label, `analyzing ${peer_core.length} entries from ${peer_info.username}`)
      
      for (let i = 0; i < peer_core.length; i++) {
        try {
          const raw_data = await peer_core.get(i)
          const entry = JSON.parse(b4a.toString(raw_data))
          
          console.log(label, `Entry ${i}: type="${entry.type}", title="${entry.title || 'N/A'}"`)
          
          if (entry.type === 'blog-post') {
              // Create a unique key for this post
              const post_key = `${hex_key}:${entry.title}:${entry.created}`
              
              if (!processed_entries.has(post_key)) {
            blog_posts++
            console.log(label, `Found blog post: "${entry.title}" (${new Date(entry.created).toLocaleString()})`)
                
                const content = await peer_drive.get(entry.filepath)
                if (content) {
                  await blog_core.append(JSON.stringify({
                    type: 'peer-blog-post',
                    peer_key: hex_key,
                    title: entry.title,
                    content: b4a.toString(content),
                    created: entry.created
                  }))
                  processed_entries.add(post_key)
                  console.log(label, `Added post "${entry.title}" to feed`)
                }
              } else {
                console.log(label, `Skipping duplicate post: "${entry.title}"`)
              }
          }
          
          processed_posts++
        } catch (err) {
          console.log(label, `Could not parse entry ${i} from ${peer_info.username}: ${err.message}`)
        }
      }
      
      console.log(label, `Check complete: ${processed_posts} total entries, ${blog_posts} blog posts`)
      
        peer_core.on('append', async () => {
          try {
            const latest = JSON.parse(b4a.toString(await peer_core.get(peer_core.length - 1)))
            if (latest.type === 'blog-post') {
              const post_key = `${hex_key}:${latest.title}:${latest.created}`
              
              if (!processed_entries.has(post_key)) {
                const content = await peer_drive.get(latest.filepath)
                if (content) {
                  await blog_core.append(JSON.stringify({
                    type: 'peer-blog-post',
                    peer_key: hex_key,
                    title: latest.title,
                    content: b4a.toString(content),
                    created: latest.created
                  }))
                  processed_entries.add(post_key)
                  console.log(label, `Added new post "${latest.title}" to feed`)
                }
              } else {
                console.log(label, `Skipping duplicate new post: "${latest.title}"`)
              }
            }
          } catch (err) {
            console.log(label, `Error processing new post: ${err.message}`)
          }
        })
        
        return true
        
      } catch (err) {
        console.error(label, `subscription error: ${err.message}`)
        return false
      }
    },
    get_peer_id_by_username: (username) => {
      for (const [peer_id, peer_info] of discovered_peers.entries()) {
        if (peer_info.username === username) {
          return peer_id
        }
      }
      return null
    }
  }
}

module.exports = {
  start: start_native_peer
}