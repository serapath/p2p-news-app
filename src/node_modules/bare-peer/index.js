const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const process = require('bare-process')
const protomux = require('protomux')
const { create_mnemonic_keypair, save, load } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')
const { initialize_autobase,  handle_identity_protocol} = require('../helpers/identity-helpers/index.js')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

/******************************************************************************
  START
******************************************************************************/

async function start_native_peer(options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  // Try to load existing seedphrase
  let seedphrase = await load(name)
  let mnemonic_data
  
  if (seedphrase) {
    console.log(label, 'Loaded existing seedphrase')
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise',
      mnemonic: seedphrase
    })
  } else {
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise'
    })
    await save(mnemonic_data.mnemonic, name)
    console.log(label, 'Generated and saved new mnemonic')
  }
  
  console.log(label, 'Generated mnemonic:', mnemonic_data.mnemonic)
  console.log(label, 'Peer key:', mnemonic_data.keypair.publicKey.toString('hex'))

  const store = new Corestore(`./storage-${name}`)
  const core = store.get({ name: 'test-core' })
  await core.ready()
  console.log(label, 'âœ… Successfully created a new core with the key')
  console.log(label, { corekey: core.key.toString('hex') })
  await core.append('Hello, peer!')

  // Initialize autobase system
  const identity_system = await initialize_autobase(store, {
    invite_key: options.inviteKey,
    forced_mode: options.mode,
    name,
    mnemonic_data,
    label
  })

  const { autobase, actual_mode, is_main_device, manually_added_writers } = identity_system
  
  const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })
  swarm.on('connection', on_connection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  

  async function on_connection(socket, info) {
    console.log(label, 'New Peer Joined, Their Public Key is: ', info.publicKey.toString('hex'))
    socket.on('error', on_error)

    const mux = new protomux(socket)

    const handlers = {
      on_protocol: async (message, send, current_peer_mode) => {
        await handle_identity_protocol(
          message, 
          autobase, 
          is_main_device, 
          manually_added_writers, 
          mnemonic_data, 
          name, 
          label
        )
      },
      
      on_feedkey: async ({ key_buffer, hex_key }, send) => {
        const cloned_core = store.get(key_buffer)
        cloned_core.on('append', async () => {
          console.log(label, 'New data appended to cloned core')
          const latest = await cloned_core.get(cloned_core.length - 1)
          console.log(label, 'Received:', latest.toString('utf-8'))
        })
        await cloned_core.ready()
        console.log(label, 'Cloned core ready:', cloned_core.key.toString('hex'))
      },

      on_autobase_key: async ({ autobase_key }, send) => {
        // Handle autobase key exchange if needed
      },

      on_writer_request: async ({ writer_key, peer_name }, send) => {
        // Manual key exchange only
      },

      on_writer_added: async ({ peer_name }, send) => {
        console.log(label, `ðŸŽ‰ Added as writer by ${peer_name}`)
      }
    }

    const init_fn = (send) => {
      send({
        type: 'protocol',
        data: {
          name: name,
          mode: actual_mode || 'native',
          device_public_key: mnemonic_data.keypair.publicKey.toString('hex')
        }
      })
      send({
        type: 'feedkey',
        data: core.key.toString('hex')
      })
    }

    // Setup protocol
    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: actual_mode || 'native',
      label
    })
    
    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    // Start replication regardless of peer type
    store.replicate(socket)
    if (autobase) {
      autobase.replicate(socket)
    }
  }

  function on_error(err) {
    console.log(label, 'socket error', err)
  }
}

module.exports = {
  start: start_native_peer
}