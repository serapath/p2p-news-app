const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const crypto = require('hypercore-crypto')
const process = require('bare-process')
const protomux = require('protomux')
const c = require('compact-encoding')
const { create_noise_keypair } = require('../helpers/crypto-helpers/index.js')
const { parseFeedKey } = require('../helpers/parsing-helpers/index.js')
const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

/******************************************************************************
  START
******************************************************************************/
async function startNativePeer (cliArgs) {
  const parsed_args = parse(cliArgs)
  const validated_args = validate(parsed_args)
  const name = validated_args['--name'] || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  const opts = {
    namespace: 'noisekeys',
    seed: crypto.randomBytes(32),
    name: 'noise'
  }
  const { publicKey, secretKey } = create_noise_keypair(opts)
  console.log(label, { peerkey: publicKey.toString('hex') })
  const key_pair = { publicKey, secretKey }
  const store = new Corestore(`./storage-${name}`)
  const core = store.get({ name: 'test-core' })
  await core.ready()
  console.log(label, 'âœ… Successfully created a new core with the key')
  console.log(label, { corekey: core.key.toString('hex') })
  await core.append('Hello, peer!')
  const swarm = new Hyperswarm({ key_pair })
  swarm.on('connection', onconnection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')
  let iid = null

  async function onconnection (socket, info) {
    console.log(label, 'New Peer Joined, Their Public Key is: ', info.publicKey.toString('hex'))
    socket.on('error', onerror)

    const mux = new protomux(socket)
    let hasReceivedFeedkey = false // Add a flag to prevent processing feedkey multiple times

    const identity_channel = mux.createChannel({
      protocol: 'identity-exchange',
      onopen: () => {
        console.log(label, 'Identity channel opened')

        const protocol_msg = identity_channel.addMessage({
          encoding: c.json,
          onmessage: async (message) => {
            try {
              // Handle identity message
              if (message.type === 'protocol') {
                console.log(label, `Peer ${message.name} is ${message.data}`)
                if (message.data === 'native') {
                  // This is a native peer connecting to another native peer
                  if (!iid) iid = setInterval(append_more, 1000)
                }
              }

              // Handle feedkey message (for both native and browser peers)
              if (message.type === 'feedkey' && !hasReceivedFeedkey) {
                hasReceivedFeedkey = true
                const keyBuffer = parseFeedKey(message.feedkey)

                if (!keyBuffer) return

                const hexKey = keyBuffer.toString('hex')
                console.log(label, 'Received peer key:', hexKey.substring(0, 16) + '...')

                const cloned_core = store.get(keyBuffer)
                cloned_core.on('append', onappend)
                await cloned_core.ready()
                console.log(label, 'Cloned core ready:', cloned_core.key.toString('hex'))

                const unavailable = []
                if (cloned_core.length) {
                  for (var i = 0, L = cloned_core.length; i < L; i++) {
                    const raw = await cloned_core.get(i, { wait: false })
                    if (raw) console.log(label, 'local:', { i, message: raw.toString('utf-8') })
                    else unavailable.push(i)
                  }
                }

                for (var i = 0, L = unavailable.sort().length; i < L; i++) {
                  const raw = await cloned_core.get(unavailable[i])
                  console.log(label, 'download:', { i: unavailable[i], message: raw.toString('utf-8') })
                }
              }

              if (message.type === 'protocol' || message.type === 'feedkey') {
                store.replicate(socket)
                if (message.type === 'feedkey' && !iid) {
                  iid = setInterval(append_more, 1000)
                }
              }
            } catch (err) {
              console.error(label, 'Error handling message:', err)
            }
          }
        })

        console.log(label, 'Sending our identity and core key')
        protocol_msg.send({
          type: 'protocol',
          name: name,
          data: 'native'
        })
        protocol_msg.send({
          type: 'feedkey',
          feedkey: core.key.toString('hex')
        })
      }
    })

    identity_channel.open()
  }

  function onerror (err) {
    clearInterval(iid)
    console.log(label, 'socket error', err)
  }

  function append_more () {
    const time = Math.floor(process.uptime())
    const stamp = `${time / 60 / 60 | 0}h:${time / 60 | 0}m:${time % 60}s`
    core.append(`uptime: ${stamp}`)
  }

  async function onappend () {
    const L = core.length
    console.log(label, 'notification: ðŸ“¥ New data available', L)
    const raw = await core.get(L - 1)
    console.log(label, { i: L - 1, message: raw.toString('utf-8') })
  }
}

/******************************************************************************
  HELPER (CLI ARGUMENTS)
******************************************************************************/

function parse (L) {
  const arr = []
  for (let i = 0; i < L.length; i += 2) arr.push([L[i], L[i + 1]])
  return Object.fromEntries(arr)
}

function validate (opts) {
  if (!opts['--name']) console.warn('Warning: --name not provided. Using default name.')
  return opts // We allow missing name now, will use default
}

module.exports = {
  start: startNativePeer
}
