const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const crypto = require('hypercore-crypto')
const process = require('bare-process')
const protomux = require('protomux')
const { create_noise_keypair } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

/******************************************************************************
  START
******************************************************************************/
async function start_native_peer (options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  const opts = {
    namespace: 'noisekeys',
    seed: crypto.randomBytes(32),
    name: 'noise'
  }
  const { publicKey, secret_key } = create_noise_keypair(opts)
  console.log(label, { peerkey: publicKey.toString('hex') })
  const key_pair = { publicKey, secret_key }
  const store = new Corestore(`./storage-${name}`)
  const core = store.get({ name: 'test-core' })
  await core.ready()
  console.log(label, 'âœ… Successfully created a new core with the key')
  console.log(label, { corekey: core.key.toString('hex') })
  await core.append('Hello, peer!')
  const swarm = new Hyperswarm({ key_pair })
  swarm.on('connection', onconnection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  async function onconnection (socket, info) {
    console.log(label, 'New Peer Joined, Their Public Key is: ', info.publicKey.toString('hex'))
    socket.on('error', onerror)

    const mux = new protomux(socket)

    // Protocol handlers
    const handlers = {
      on_protocol: async (message, send, current_peer_mode) => {
      },
      
      on_feedkey: async ({ key_buffer, hex_key }, send) => {
        const cloned_core = store.get(key_buffer)
        cloned_core.on('append', async () => {
          console.log(label, 'New data appended to cloned core')
          const latest = await cloned_core.get(cloned_core.length - 1)
          console.log(label, 'Received:', latest.toString('utf-8'))
        })
        await cloned_core.ready()
        console.log(label, 'Cloned core ready:', cloned_core.key.toString('hex'))
      }
    }

    // Initialization function
    const init_fn = (send) => {
      send({
        type: 'protocol',
        data: {
          name: name,
          mode: 'native'
        }
      })
      send({
        type: 'feedkey',
        data: core.key.toString('hex')
      })
    }

    // Setup protocol
    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: 'native',
      label
    })
    
    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    // Start replication regardless of peer type
    store.replicate(socket)
  }

  function onerror (err) {
    console.log(label, 'socket error', err)
  }
}

module.exports = {
  start: start_native_peer
}