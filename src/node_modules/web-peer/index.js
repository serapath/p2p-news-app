const b4a = require('b4a')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')
const Protomux = require('protomux')
const c = require('compact-encoding')
const Corestore = require('corestore')
const RAM = require('random-access-memory')
const crypto = require('hypercore-crypto')
const { create_noise_keypair } = require('../helpers/crypto-helpers/index.js')
const { parseFeedKey } = require('../helpers/parsing-helpers/index.js')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

const store = new Corestore(RAM.reusable())
const core = store.get({ name: 'test-core' })

async function startBrowserPeer (args = {}) {
  const socket = new WebSocket('ws://localhost:8080')
  socket.addEventListener('open', () => {
    console.log('Connected to DHT relay')

    const opts = {
      namespace: 'noisekeys',
      seed: crypto.randomBytes(32),
      name: 'noise'
    }
    const key_pair = create_noise_keypair(opts)
    console.log({ peerkey: key_pair.publicKey.toString('hex') })

    const dht = new DHT(new Stream(true, socket))
    const swarm = new Hyperswarm({ dht, key_pair })

    const join = () => swarm.join(topic, { server: true, client: true }).flushed()
    join().then(() => console.log('Joined swarm'))
    setInterval(join, 5000)

    swarm.on('connection', (relay, details) => {
      console.log('New peer connected')

      if (!relay.userData) relay.userData = null

      const mux = new Protomux(relay)
      let hasReceivedFeedkey = false

      const identity_channel = mux.createChannel({
        protocol: 'identity-exchange',
        onopen: () => {
          const protocol_msg = identity_channel.addMessage({
            encoding: c.json,
            onmessage: async (message) => {
              try {
                if (message.type === 'protocol') {
                  console.log(`Peer type: ${message.data}`)

                  if (message.data === 'browser') {
                    const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
                    console.log('Upgrading to WebRTC...')

                    stream.on('open', () => {
                      console.log('WebRTC connection established')
                      protocol_msg.send({
                        type: 'feedkey',
                        feedkey: core.key.toString('hex')
                      })
                      store.replicate(stream)
                    })

                    stream.on('close', () => console.log('WebRTC connection closed'))
                    stream.on('error', (err) => console.error('WebRTC error:', err))
                  } else if (message.data === 'native') {
                    console.log('Native peer connected, sending our feedkey...')
                    protocol_msg.send({
                        type: 'feedkey', 
                        feedkey: core.key.toString('hex')
                    })
                    store.replicate(relay)
                }
                } else if (message.type === 'feedkey' && !hasReceivedFeedkey) {
                  hasReceivedFeedkey = true

                  const keyBuffer = parseFeedKey(message.feedkey)

                  if (!keyBuffer) return

                  const hexKey = keyBuffer.toString('hex')
                  console.log('Received peer key:', hexKey.substring(0, 16) + '...')

                  const cloned_core = store.get(keyBuffer)
                  cloned_core.on('append', async () => {
                    console.log('New data appended to cloned core')
                    const latest = await cloned_core.get(cloned_core.length - 1)
                    console.log('Received:', latest.toString('utf-8'))
                  })
                  cloned_core.ready().then(() => {
                    console.log('Cloned core ready:', cloned_core.key.toString('hex'))
                  }).catch(err => console.error('Error with cloned core:', err))
                }
              } catch (err) {
                console.error('Message handling error:', err)
              }
            }
          })

          console.log('Sending our identity')
          protocol_msg.send({
            type: 'protocol',
            name: args.name || 'browser-peer',
            data: 'browser'
          })
        }
      })

      identity_channel.open()
      relay.on('close', () => console.log('Peer disconnected'))
      relay.on('error', (err) => console.error('Relay error:', err))
    })
  })

  socket.addEventListener('error', console.error)
  socket.addEventListener('close', () => console.log('WebSocket closed'))
}

module.exports = {
  start: startBrowserPeer
}
