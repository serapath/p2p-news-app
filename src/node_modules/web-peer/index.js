const b4a = require('b4a')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')
const Protomux = require('protomux')
const Corestore = require('corestore')
const RAM = require('random-access-memory')
const crypto = require('hypercore-crypto')
const { create_noise_keypair } = require('helpers/crypto-helpers')
const { identity_exchange_protocol } = require('helpers/protocol-helpers')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

const store = new Corestore(RAM.reusable())
const core = store.get({ name: 'test-core' })

async function start_browser_peer (options = {}) {

  const isDev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')

  const socket = new WebSocket(
    isDev
      ? `ws://localhost:8080`
      : 'wss://p2p-relay-production.up.railway.app'
  )
  

  socket.addEventListener('open', () => {
    console.log('Connected to DHT relay')

    const opts = {
      namespace: 'noisekeys',
      seed: crypto.randomBytes(32),
      name: 'noise'
    }
    const key_pair = create_noise_keypair(opts)
    console.log({ peerkey: key_pair.publicKey.toString('hex') })

    const dht = new DHT(new Stream(true, socket))
    const swarm = new Hyperswarm({ dht, key_pair })

    const join = () => swarm.join(topic, { server: true, client: true }).flushed()
    join().then(() => console.log('Joined swarm'))
    setInterval(join, 5000)

    swarm.on('connection', (relay, details) => {
      console.log('New peer connected')

      if (!relay.userData) relay.userData = null

      const mux = new Protomux(relay)

      // Protocol handlers
      const handlers = {
        on_protocol: async (message, send, current_peer_mode) => {
          console.log(`Peer type: ${message.data.mode}`)

          if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
            const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
            console.log('Upgrading to WebRTC...')

            stream.on('open', () => {
              console.log('WebRTC connection established')
              
              send({
                type: 'feedkey',
                data: core.key.toString('hex')
              })
              store.replicate(stream)
            })

            stream.on('close', () => console.log('WebRTC connection closed'))
            stream.on('error', (err) => console.error('WebRTC error:', err))
          } else if (message.data.mode === 'native') {
            console.log('Native peer connected, sending our feedkey...')
            
            send({
              type: 'feedkey', 
              data: core.key.toString('hex')
            })
            store.replicate(relay)
          }
        },
        
        on_feedkey: async ({ key_buffer, hex_key }, send) => {
          const cloned_core = store.get(key_buffer)
          cloned_core.on('append', async () => {
            console.log('New data appended to cloned core')
            const latest = await cloned_core.get(cloned_core.length - 1)
            console.log('Received:', latest.toString('utf-8'))
          })
          cloned_core.ready().then(() => {
            console.log('Cloned core ready:', cloned_core.key.toString('hex'))
          }).catch(err => console.error('Error with cloned core:', err))
        }
      }

      const init_fn = (send) => {
        send({
          type: 'protocol',
          data: {
            name: options.name || 'browser-peer',
            mode: 'browser'
          }
        })
      }

      const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
        peer_mode: 'browser',
        label: '[browser-peer]'
      })
      
      const identity_channel = setup_protocol(mux)
      identity_channel.open()
      
      relay.on('close', () => console.log('Peer disconnected'))
      relay.on('error', (err) => console.error('Relay error:', err))
    })
  })

  socket.addEventListener('error', console.error)
  socket.addEventListener('close', () => console.log('WebSocket closed'))
}

module.exports = {
  start: start_browser_peer
}